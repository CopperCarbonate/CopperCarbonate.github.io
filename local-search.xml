<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动态 dp 学习笔记</title>
    <link href="/2022/11/03/%E5%8A%A8%E6%80%81-dp-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/03/%E5%8A%A8%E6%80%81-dp-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>好耶！来学新算法了（最近停课了就有时间学算法啦</p><p>因为 CSP-S 考了个什么 ddp 然后我不会</p><p>（CSP炸了）</p><p>学了一个晚上加一个上午才学会（我太菜了）</p><p>嗯嗯其实说起来是个很简单的东西.</p><h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><p>树上dp，线段树，树链剖分，矩阵优化线性 dp</p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><p><a href="https://www.luogu.com.cn/problem/P4719">【模板】”动态 DP”&amp;动态树分治  </a></p><p>给你一棵 $n$ 个节点的树，点有点权，有 $m$ 次单点修改操作，每次求出一个独立点集（集合内任意两点没有边相连）的最大权值和.（ $1\le n,m \le 10^5$ ）</p><h3 id="O-nm-暴力"><a href="#O-nm-暴力" class="headerlink" title="$O(nm)$ 暴力"></a>$O(nm)$ 暴力</h3><p>首先 $O(nm)$ 暴力很简单，直接对每次操作做一遍 dp 就好了.</p><p>记 $f_{u,0&#x2F;1}$ 表示 $u$ 的子树内独立点集的最大权值和.</p><p>状态很好转移：<br>$$<br>f_{u,0}&#x3D;\sum_{v\in son_u} f_{v,1} \<br>f_{u,1}&#x3D;a_u+\sum_{v\in son_u} \max{f_{v,0},f_{v,1}}<br>$$</p><h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>那么我们来考虑怎么去优化这个东西吧！</p><p>我们看每次修改操作之后节点的 dp 值会怎么变化：</p><p>我们看式子就能发现，因为每个点的 dp 值是从他的子节点转移来的，所以当你调教了一个点，让它点权发生变化之后，<strong>只会对它到根节点路径上的这些点产生影响</strong>.</p><p>只有一条链上的 dp 值发生变化，但暴力算法每次把全部值都重新求了一遍，显然很暴力.（很优美bushi）</p><p>但是只改链上的 dp 值，这样做最坏情况也是  $O(nm)$  的.</p><p>诶那我们又注意到：有修改操作显然要用到数据结构呢（当然也不一定</p><p>想到之前各种树剖+线段树题（比如最经典的：<a href="http://59.61.75.5:8018/p/P3061">重建</a>）</p><p>我们想想怎么把这两个东西套起来（</p><p>最重要的一点就是树剖+<strong>线段树维护的信息必须要是满足幺半群性质</strong>的，也就是他要支持可合并性和结合律之类的.</p><p>而我们的 dp 式子是递推，不太好在线段树上维护.</p><p>那我们联想到：</p><p>形如 $f_i&#x3D;Af_{i-1}+Bf_{i-2}$ （可能有更多项）的线性递推式可以使用矩阵乘法优化，这样调教一下式子，就可以让每一次递推变成一次矩阵乘法，而矩阵乘法性质是很好的（没有时间出矩阵乘法的各种应用啦 摆烂！）<br>$$<br>\left[\begin{array}{m}<br>A &amp; B\<br>1 &amp; 0<br>\end{array}\right]<br>\left[\begin{array}{m}<br>f_{i-1}\<br>f_{i-2}<br>\end{array}\right]<br>&#x3D;<br>\left[ \begin{array}{m}<br>f_{i}\<br>f_{i-1}<br>\end{array} \right]<br>$$<br>再这样调教一下式子：<br>$$<br>\left[\begin{array}{m}<br>A &amp; B\<br>1 &amp; 0<br>\end{array}\right]^n<br>\left[\begin{array}{m}<br>f_{1}\<br>f_{0}<br>\end{array}\right]<br>&#x3D;<br>\left[ \begin{array}{m}<br>f_{n+1}\<br>f_{n}<br>\end{array} \right]<br>$$<br>诶然后矩阵快速幂不就完了</p><p>那我们可以轻松类比这题，让每一个递推变成一个矩阵！</p><p>（显然一点都不轻松不然这题就不会作为模板题形成一个单独的算法让我学了快一天 谁没见过还想得到这个啊啊啊.jpg）</p><p>那我们就通过查看题解的方式了解到：我们这个线性递推一个很重要一点就是每一次的 dp 式子是一样的，矩阵互不干扰，你如果修改了上一个节点的信息，下一个矩阵值也不一样了，显然是比较不好的一个东西</p><p>所以我们重新设计一下状态（设计状态是 dp 一个很重要的东西，可惜我不会）</p><p>我们令 <strong>$g_{u,0&#x2F;1}$ 表示 $u$ 子树，除去了 $hson[u]$ 的子树，这些点的独立点集的最大权值和</strong>，这样做呢，是不是更新的时候就可以让重链上节点的更新互不影响.</p><p>（$hson[u]$ 是重儿子）</p><p>于是我们就有一个新的 dp 式子<br>$$<br>f_{u,0}&#x3D;\max{f_{v,0},f_{v,1}}+g_{u,0}\<br>f_{u,1}&#x3D;f_{v,0}+g_{u,1}<br>$$<br>（其中 $v&#x3D;hson[u]$ ）</p><p>呃呃是不是假的啊，这个 $\max$ 根本去不掉，怎么写成矩阵乘法的形式啊？！不太可能吧ww</p><p>这又是一个套路（记下来！虽然快退役了但是感觉记下来总是好的）</p><p><strong>类比加法与乘法，$\max&#x2F;\min$ 和加法也可以定义一种类似矩阵乘法的东西</strong></p><p>怎么定义呢：</p><p>这是原版矩阵乘法：<br>$$<br>C&#x3D;AB\Rightarrow C_{i,j}&#x3D;\sum_k A_{i,k}B_{k,j}<br>$$<br>那我们就把加法换成 $\max$，把乘法换成加法</p><p>得到这个高仿 $A\otimes B$ 运算（ 电灯泡 &#x2F; 雾 ）：<br>$$<br>C&#x3D;A\otimes B\Rightarrow C_{i,j}&#x3D;\max_k{ A_{i,k}+B_{k,j}}<br>$$<br>那他为什么满足矩阵乘法的各种性质呢（群论知识，我不会，长大后再学习！）</p><p>简单证明：<br>$$<br>\begin{align*}<br>&amp; A \otimes (B \otimes C)&#x3D;(A \otimes B) \otimes C\<br>\Leftrightarrow\ &amp; \forall i,j\<br>\max_k{ A_{i,k}+\max_t{ B_{k,t}+C_{t,j}}}&#x3D;<br>\max_k{ \max_t{ A_{i,t}+B_{t,k}}+C_{k,j}}\<br>\Leftrightarrow\ &amp; \forall i,j\<br>\max_k{ \max_t{A_{i,k}+ B_{k,t}+C_{t,j}}}&#x3D;<br>\max_k{ \max_t{ A_{i,t}+B_{t,k}+C_{k,j}}}<br>\end{align*}<br>$$<br>交换 $k,t$ 完显然成立</p><p>（注意到这个证明依赖于 $\max$ 对加法的分配率，由此可以看出它也构成一个环）</p><p>嗯嗯然后呢我们把上面那个式子改成矩阵 $\otimes$ 法的形式</p><p>上面的式子：<br>$$<br>f_{u,0}&#x3D;\max{f_{v,0},f_{v,1}}+g_{u,0}\<br>f_{u,1}&#x3D;f_{v,0}+g_{u,1}<br>$$<br>调教：<br>$$<br>f_{u,0}&#x3D;\max{f_{v,0}+g_{u,0},f_{v,1}+g_{u,0}}\<br>f_{u,1}&#x3D;\max{f_{v,0}+g_{u,1},-\infin}<br>$$<br>继续调教：<br>$$<br>\left[\begin{array}{m}<br>g_{u,0} &amp; g_{u,0}\<br>g_{u,1} &amp; -\infin<br>\end{array}\right]<br>\otimes<br>\left[\begin{array}{m}<br>f_{v,0}\<br>f_{v,1}<br>\end{array}\right]<br>&#x3D;<br>\left[ \begin{array}{m}<br>f_{u,0}\<br>f_{u,1}<br>\end{array} \right]<br>$$</p><p>嗯嗯这就成一个可以在线段树上维护的东西了.</p><p><strong>怎么实现呢？</strong></p><p>首先先一次 dp 求出每个点的 $f$ 和 $g$，把 $g$ 存到矩阵里</p><p>树剖，建线段树，注意线段树上是按 dfs 序存</p><p>这时候每次怎么求出答案呢</p><p>答案就是 $\max{f_{1,0},f_{1,1}}$</p><p>其实就是以 $1$ 号节点为顶的这条重链上所有矩阵的 $\otimes$  积（</p><p>那我们每次修改操作，单点修改完 $u$，哪些点的矩阵会发生变化？</p><p>显然只有每次的 $fa[top[u]]$，因为根据定义， $g$ 只会从轻儿子转移来.</p><p>因为从 $u$ 到 $1$ 最多经过 $\log n$ 条重链，所以总体的时间复杂度是 $O(m\log^2n)$</p><p>实现的细节看代码：</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//https://www.luogu.com.cn/problem/P4719 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, inf = <span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mat</span> <span class="hljs-comment">//Matrix</span><br>&#123;<br><span class="hljs-type">int</span> r,c;<br><span class="hljs-type">int</span> d[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;r; i++) &#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;c; j++) <span class="hljs-keyword">if</span>(d[i][j]&gt;-inf) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%4d &quot;</span>,d[i][j]); <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-inf &quot;</span>); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>); &#125; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">st</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; v)</span> <span class="hljs-comment">//初始化矩阵</span></span><br><span class="hljs-function"></span>&#123;<br>r=v.<span class="hljs-built_in">size</span>(); c=v[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;r; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;c; j++) d[i][j]=v[i][j];<br>&#125;<br><span class="hljs-type">int</span> * <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> d[x]; &#125; <span class="hljs-comment">//小科技，可以把A.d[i][j]变成A[i][j]</span><br><span class="hljs-keyword">friend</span> Mat <span class="hljs-keyword">operator</span> ^ (Mat a, Mat b) <span class="hljs-comment">//重定义矩阵乘法</span><br>&#123;<br><span class="hljs-built_in">assert</span>(a.c==b.r); Mat c; c.r=a.r; c.c=b.c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;a.r; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;b.c; j++)<br>&#123;<br>c[i][j]=-inf; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;a.c; k++) c[i][j]=<span class="hljs-built_in">max</span>(c[i][j],a[i][k]+b[k][j]);<br>&#125;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br>&#125;;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; g[N]; <br><span class="hljs-type">int</span> fa[N],sz[N],d[N],dfn[N],rk[N],hson[N],top[N],btm[N],ct; <span class="hljs-comment">//树剖</span><br>Mat F[N],G[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sagiri</span> <span class="hljs-comment">//Segment tree</span><br>&#123;<br><span class="hljs-type">int</span> l,r;<br>Mat dat;<br>&#125; t[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p&lt;&lt;1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p&lt;&lt;1)|1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>t[p].l=l,t[p].r=r;<br><span class="hljs-keyword">if</span>(l==r) &#123; t[p].dat=G[rk[l]]; <span class="hljs-keyword">return</span> ; &#125;<br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(ls,l,mid),<span class="hljs-built_in">build</span>(rs,mid+<span class="hljs-number">1</span>,r);<br>t[p].dat=t[ls].dat^t[rs].dat;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> Mat &amp;v)</span> <span class="hljs-comment">//结构体记得传实参</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(t[p].l==t[p].r) &#123; t[p].dat=v; <span class="hljs-keyword">return</span> ; &#125;<br><span class="hljs-type">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid) <span class="hljs-built_in">change</span>(ls,x,v);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">change</span>(rs,x,v);<br>t[p].dat=t[ls].dat^t[rs].dat;<br>&#125;<br><span class="hljs-function">Mat <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(t[p].l==l <span class="hljs-keyword">and</span> t[p].r==r) <span class="hljs-keyword">return</span> t[p].dat;<br><span class="hljs-type">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(r&lt;=mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls,l,r);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&gt;mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs,l,r);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls,l,mid)^<span class="hljs-built_in">query</span>(rs,mid+<span class="hljs-number">1</span>,r); <span class="hljs-comment">/**/</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slpf1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> prv)</span></span><br><span class="hljs-function"></span>&#123;<br>fa[u]=prv; sz[u]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:g[u])<br>&#123;<br><span class="hljs-keyword">if</span>(v==prv) <span class="hljs-keyword">continue</span>;<br>d[v]=d[u]+<span class="hljs-number">1</span>; <span class="hljs-built_in">slpf1</span>(v,u); sz[u]+=sz[v];<br><span class="hljs-keyword">if</span>(sz[v]&gt;sz[hson[u]]) hson[u]=v;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slpf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>dfn[u]=++ct; rk[dfn[u]]=u; btm[u]=u;<br>F[u].<span class="hljs-built_in">st</span>(&#123;&#123;<span class="hljs-number">0</span>&#125;,&#123;a[u]&#125;&#125;);<br>G[u].<span class="hljs-built_in">st</span>(&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;a[u],-inf&#125;&#125;);<br><span class="hljs-keyword">if</span>(hson[u]) <br>&#123;<br><span class="hljs-type">int</span> v=hson[u]; top[v]=top[u]; <span class="hljs-built_in">slpf2</span>(v); btm[u]=btm[v];<br>F[u][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(F[v][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],F[v][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>F[u][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+=F[v][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:g[u])<br>&#123;<br><span class="hljs-keyword">if</span>(v==fa[u] <span class="hljs-keyword">or</span> v==hson[u]) <span class="hljs-keyword">continue</span>;<br>top[v]=v; <span class="hljs-built_in">slpf2</span>(v);<br>F[u][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(F[v][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],F[v][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>F[u][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+=F[v][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>G[u][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(F[v][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],F[v][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>G[u][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+=F[v][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">//G只由轻儿子转移</span><br>&#125;<br>G[u][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=G[u][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,u,v; i&lt;n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),g[u].<span class="hljs-built_in">push_back</span>(v),g[v].<span class="hljs-built_in">push_back</span>(u);<br><span class="hljs-built_in">slpf1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>); top[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>; <span class="hljs-built_in">slpf2</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>G[u][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+=w-a[u]; a[u]=w; <span class="hljs-comment">//先修改u的矩阵</span><br><span class="hljs-keyword">while</span>(u)<br>&#123;<br>Mat st=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,dfn[top[u]],dfn[btm[u]]); <br><span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>,dfn[u],G[u]); <span class="hljs-comment">//求出修改前和修改后轻儿子的贡献，就可以改变fa[top[u]]的矩阵</span><br>Mat ed=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,dfn[top[u]],dfn[btm[u]]);<br>u=fa[top[u]];<br>G[u][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(ed[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],ed[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])-<span class="hljs-built_in">max</span>(st[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],st[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>G[u][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=G[u][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>G[u][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+=ed[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]-st[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">answer_query</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,u,w; i&lt;=m; i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;w);<br><span class="hljs-built_in">update</span>(u,w);<br>Mat ans=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,dfn[<span class="hljs-number">1</span>],dfn[btm[<span class="hljs-number">1</span>]]); <span class="hljs-comment">//答案即这条重链的矩阵之积</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">max</span>(ans[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],ans[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]));<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">answer_query</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小练习："><a href="#小练习：" class="headerlink" title="小练习："></a>小练习：</h2><p><a href="https://www.luogu.com.cn/problem/P5024">NOIP2018 提高组 D2T3</a></p><p>这题没差多少</p><p>只是稍微变化了一下 dp 式子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-comment">//#define debug</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> ll inf = <span class="hljs-number">1e17</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mat</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">2</span>;<br>ll d[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>ll * <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> d[x]; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(vector&lt;vector&lt;ll&gt; &gt; v)</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;B; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;B; j++) d[i][j]=v[i][j]; &#125;<br><span class="hljs-keyword">friend</span> Mat <span class="hljs-keyword">operator</span>^ (Mat a, Mat b)<br>&#123;<br>Mat c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;B; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;B; j++)<br>&#123;<br>c[i][j]=inf;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;B; k++)<br>c[i][j]=<span class="hljs-built_in">min</span>(c[i][j],a[i][k]+b[k][j]);<br>&#125;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> n,m;<br>ll a[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; g[N];<br><span class="hljs-type">int</span> fa[N],d[N],dfn[N],rk[N],sz[N],hson[N],top[N],btm[N],ct;<br>ll F[N][<span class="hljs-number">2</span>];<br>Mat G[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sagiri</span><br>&#123;<br><span class="hljs-type">int</span> l,r;<br>Mat dat;<br>&#125; t[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p&lt;&lt;1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p&lt;&lt;1)|1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>t[p].l=l,t[p].r=r;<br><span class="hljs-keyword">if</span>(l==r) &#123; t[p].dat=G[rk[l]]; <span class="hljs-keyword">return</span> ; &#125;<br><span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(ls,l,mid),<span class="hljs-built_in">build</span>(rs,mid+<span class="hljs-number">1</span>,r);<br>t[p].dat=t[ls].dat^t[rs].dat;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> Mat &amp;v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(t[p].l==t[p].r) &#123; t[p].dat=v; <span class="hljs-keyword">return</span> ; &#125;<br><span class="hljs-type">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid) <span class="hljs-built_in">update</span>(ls,x,v);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(rs,x,v);<br>t[p].dat=t[ls].dat^t[rs].dat;<br>&#125;<br><span class="hljs-function">Mat <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(t[p].l==l <span class="hljs-keyword">and</span> t[p].r==r) <span class="hljs-keyword">return</span> t[p].dat;<br><span class="hljs-type">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(r&lt;=mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls,l,r);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&gt;mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs,l,r);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls,l,mid)^<span class="hljs-built_in">query</span>(rs,mid+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slpf1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> prv)</span></span><br><span class="hljs-function"></span>&#123;<br>fa[u]=prv; sz[u]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:g[u])<br>&#123;<br><span class="hljs-keyword">if</span>(v==prv) <span class="hljs-keyword">continue</span>;<br>d[v]=d[u]+<span class="hljs-number">1</span>; <span class="hljs-built_in">slpf1</span>(v,u); sz[u]+=sz[v];<br><span class="hljs-keyword">if</span>(sz[v]&gt;sz[hson[u]]) hson[u]=v;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slpf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>dfn[u]=++ct,rk[dfn[u]]=u; btm[u]=u;<br>F[u][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>,F[u][<span class="hljs-number">1</span>]=a[u];<br>G[u].<span class="hljs-built_in">init</span>(&#123;&#123;inf,<span class="hljs-number">0</span>&#125;,&#123;a[u],a[u]&#125;&#125;);<br><span class="hljs-keyword">if</span>(hson[u])<br>&#123;<br><span class="hljs-type">int</span> v=hson[u];<br>top[v]=top[u]; <span class="hljs-built_in">slpf2</span>(v); btm[u]=btm[v];<br>F[u][<span class="hljs-number">0</span>]+=F[v][<span class="hljs-number">1</span>]; F[u][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">min</span>(F[v][<span class="hljs-number">0</span>],F[v][<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:g[u])<br>&#123;<br><span class="hljs-keyword">if</span>(v==fa[u] <span class="hljs-keyword">or</span> v==hson[u]) <span class="hljs-keyword">continue</span>;<br>top[v]=v; <span class="hljs-built_in">slpf2</span>(v);<br>F[u][<span class="hljs-number">0</span>]+=F[v][<span class="hljs-number">1</span>]; F[u][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">min</span>(F[v][<span class="hljs-number">0</span>],F[v][<span class="hljs-number">1</span>]);<br>G[u][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+=F[v][<span class="hljs-number">1</span>]; G[u][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">min</span>(F[v][<span class="hljs-number">0</span>],F[v][<span class="hljs-number">1</span>]);<br>&#125;<br>G[u][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=G[u][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> u, ll w)</span></span><br><span class="hljs-function"></span>&#123;<br>G[u][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+=w-a[u]; G[u][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=G[u][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]; a[u]=w;<br><span class="hljs-keyword">while</span>(u!=<span class="hljs-number">0</span>)<br>&#123;<br>Mat st=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,dfn[top[u]],dfn[btm[u]]);<br><span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>,dfn[u],G[u]);<br>Mat ed=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,dfn[top[u]],dfn[btm[u]]);<br>u=fa[top[u]];<br>G[u][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">min</span>(ed[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],ed[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])-<span class="hljs-built_in">min</span>(st[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],st[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>G[u][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+=ed[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-st[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>G[u][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=G[u][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m); cin&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,u,v; i&lt;n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),g[u].<span class="hljs-built_in">push_back</span>(v),g[v].<span class="hljs-built_in">push_back</span>(u);<br><span class="hljs-built_in">slpf1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),top[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>,<span class="hljs-built_in">slpf2</span>(<span class="hljs-number">1</span>); <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,qa,x,qb,y; <span class="hljs-built_in">i</span>&lt;=m; i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;qa,&amp;x,&amp;qb,&amp;y);<br>ll ta=a[qa],tb=a[qb];<br><span class="hljs-built_in">change</span>(qa,x?<span class="hljs-number">0</span>:inf); <span class="hljs-built_in">change</span>(qb,y?<span class="hljs-number">0</span>:inf);<br>Mat res=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,dfn[<span class="hljs-number">1</span>],dfn[btm[<span class="hljs-number">1</span>]]);<br>ll ans=<span class="hljs-built_in">min</span>(res[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],res[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">if</span>(x) ans+=ta; <span class="hljs-keyword">if</span>(y) ans+=tb;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans&gt;(inf/<span class="hljs-number">2</span>)?<span class="hljs-number">-1</span>:ans);<br><span class="hljs-built_in">change</span>(qa,ta); <span class="hljs-built_in">change</span>(qb,tb);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>动态dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算几何技巧合集</title>
    <link href="/2022/11/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/"/>
    <url>/2022/11/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DTOJ 2022-11-02 图论专题</title>
    <link href="/2022/11/02/DTOJ-2022-11-02-%E5%9B%BE%E8%AE%BA%E4%B8%93%E9%A2%98/"/>
    <url>/2022/11/02/DTOJ-2022-11-02-%E5%9B%BE%E8%AE%BA%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题单"><a href="#题单" class="headerlink" title="题单"></a>题单</h1><p><a href="http://59.61.75.5:8018/p/P1117">P1117 无序字母对</a></p><p><a href="http://59.61.75.5:8018/p/P5240">P5240「NOIP2020」排水系统</a></p><p><a href="http://59.61.75.5:8018/p/P4042">P4042「NOIP2018」旅行</a></p><p><a href="http://59.61.75.5:8018/p/P5169">P5169「CSP-S 2020」函数调用</a></p><p><a href="http://59.61.75.5:8018/p/P4563">P4563 「NOIP2017」逛公园</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>给定 $n$ 个各不相同的无序字母对（区分大小写，无序即字母对中的两个字母可以位置颠倒）。</p><p>请构造一个有 $n+1$ 个字母的字符串使得每个字母对都在这个字符串中出现。</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>建图，欧拉路径模板.</p><p>欧拉路径这东西貌似没考过.</p><p>但是知道他可以dfs直接做就好了</p><p>（可能是因为复杂度太高）</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fs first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>, M = <span class="hljs-number">52</span>;<br><span class="hljs-type">int</span> n,deg[N],a[N*N],tp,flag=<span class="hljs-number">0</span>,vt[N*N];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; g[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ch_to_id</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">assert</span>(<span class="hljs-built_in">isalpha</span>(c));<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;A&#x27;</span>&lt;=c <span class="hljs-keyword">and</span> c&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>) <span class="hljs-keyword">return</span> c-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> c-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>+<span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id_to_ch</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">assert</span>(<span class="hljs-number">1</span>&lt;=d <span class="hljs-keyword">and</span> d&lt;=<span class="hljs-number">52</span>);<br><span class="hljs-keyword">if</span>(d&lt;=<span class="hljs-number">26</span>) <span class="hljs-keyword">return</span> d+<span class="hljs-string">&#x27;A&#x27;</span><span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> d<span class="hljs-number">-27</span>+<span class="hljs-string">&#x27;a&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//printf(&quot;%c &quot;,id_to_ch(u));</span><br>a[++tp]=u;<br><span class="hljs-keyword">if</span>(tp&gt;=n+<span class="hljs-number">1</span>) &#123; flag=<span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> ; &#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:g[u])<br>&#123;<br><span class="hljs-keyword">if</span>(vt[e.sc]) <span class="hljs-keyword">continue</span>;<br>vt[e.sc]=<span class="hljs-number">1</span>; <span class="hljs-built_in">dfs</span>(e.fs); vt[e.sc]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;<br>tp--;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>&#123;<br><span class="hljs-type">char</span> s[<span class="hljs-number">4</span>]; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br><span class="hljs-type">int</span> u=<span class="hljs-built_in">ch_to_id</span>(s[<span class="hljs-number">0</span>]),v=<span class="hljs-built_in">ch_to_id</span>(s[<span class="hljs-number">1</span>]);<br>g[u].<span class="hljs-built_in">push_back</span>(&#123;v,i&#125;),g[v].<span class="hljs-built_in">push_back</span>(&#123;u,i&#125;); deg[u]++,deg[v]++;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=M; i++) <span class="hljs-built_in">sort</span>(g[i].<span class="hljs-built_in">begin</span>(),g[i].<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//for(int i=1; i&lt;=M; i++) if(g[i].size()) &#123; for(auto e:g[i]) printf(&quot;(%c %c)&quot;,id_to_ch(i),id_to_ch(e.fs)); puts(&quot;&quot;); &#125;</span><br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,st=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=M; i; i--) <span class="hljs-keyword">if</span>(deg[i]) st=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=M; i; i--) <span class="hljs-keyword">if</span>(deg[i]&amp;<span class="hljs-number">1</span>) st=i,cnt++;<br><span class="hljs-keyword">if</span>(cnt!=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> cnt!=<span class="hljs-number">2</span>) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No Solution&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">dfs</span>(st);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=tp; i++) <span class="hljs-built_in">putchar</span>(<span class="hljs-built_in">id_to_ch</span>(a[i]));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题面：-1"><a href="#题面：-1" class="headerlink" title="题面："></a>题面：</h3><p>DAG， $1 \le n \le 10^5,1 \le m \le 10$，入度为零的点初始有 $1$ 的水，每个节点会均等地把水流向之后的点，问最后每个出度为零的点多少水.</p><h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>拓扑排序模板，当年 NOIP 的时候我没做出来，实在太菜了ww）</p><p>按照拓扑序做就好了.</p><p>注意分数要开 __int128.</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n,m,deg_o[N],deg_i[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">prt</span><span class="hljs-params">(<span class="hljs-type">__int128_t</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        x = -x;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">9</span>)<br>        <span class="hljs-built_in">prt</span>(x / <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Misaka</span><br>&#123;<br><span class="hljs-type">__int128_t</span> p,q;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">prt</span>(p),<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>),<span class="hljs-built_in">prt</span>(q),<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>); &#125;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> Misaka <span class="hljs-title">yf</span><span class="hljs-params">(Misaka a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(a.p==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">__int128_t</span> g=__gcd(a.p,a.q); <span class="hljs-keyword">if</span>(g&lt;<span class="hljs-number">0</span>) g=-g;<br>a.p/=g,a.q/=g; <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-keyword">friend</span> Misaka <span class="hljs-keyword">operator</span>+ (Misaka a, Misaka b) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">yf</span>((Misaka)&#123;a.p*b.q+b.p*a.q,a.q*b.q&#125;); &#125;<br><span class="hljs-keyword">friend</span> Misaka <span class="hljs-keyword">operator</span>/ (Misaka a, ll k) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">yf</span>((Misaka)&#123;a.p,k*a.q&#125;); &#125;<br>&#125;f[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; g[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;deg_o[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,u; j&lt;=deg_o[i]; j++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;u),g[i].<span class="hljs-built_in">push_back</span>(u),deg_i[u]++;<br>&#125;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) q.<span class="hljs-built_in">push</span>(i),f[i]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m+<span class="hljs-number">1</span>; i&lt;=n; i++) f[i]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:g[u]) <br>&#123;<br>f[v]=f[v]+f[u]/deg_o[u]; deg_i[v]--;<br><span class="hljs-keyword">if</span>(deg_i[v]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(v);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-keyword">if</span>(deg_o[i]==<span class="hljs-number">0</span>) f[i].<span class="hljs-built_in">print</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题面：-2"><a href="#题面：-2" class="headerlink" title="题面："></a>题面：</h3><p>树或基环树，dfs序的字典序最小.</p><h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>树很简单，每个点排个序直接dfs就好啦！</p><p>基环树也很简单，注意到 $O(n^2)$ 可以过，所以直接暴力枚举删的一条边，转成树，再dfs也就好啦！</p><p>稍微有点小卡常..</p><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fs first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5005</span>;<br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">int</span>&gt; g[N];<br><span class="hljs-type">int</span> ans[N],r[N],nr,vt[N];<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; dlt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x; <span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch=<span class="hljs-built_in">getchar</span>()));<br><span class="hljs-keyword">for</span>(x=(ch^<span class="hljs-number">48</span>); <span class="hljs-built_in">isdigit</span>(ch=<span class="hljs-built_in">getchar</span>()); x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>));<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">if</span>(ans[i]&lt;r[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ans[i]&gt;r[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>r[++nr]=u; vt[u]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:g[u])<br>&#123;<br><span class="hljs-keyword">if</span>(vt[v] <span class="hljs-built_in">or</span> (u==dlt.fs <span class="hljs-keyword">and</span> v==dlt.sc) <span class="hljs-built_in">or</span> (u==dlt.sc <span class="hljs-keyword">and</span> v==dlt.fs)) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs1</span>(v);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:g[i])<br>&#123;<br><span class="hljs-keyword">if</span>(i&gt;v) <span class="hljs-keyword">continue</span>; <br>nr=<span class="hljs-number">0</span>; dlt=&#123;i,v&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) vt[i]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>); <br><span class="hljs-keyword">if</span>(nr!=n) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>()) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) ans[i]=r[i];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>n=<span class="hljs-built_in">rd</span>(); m=<span class="hljs-built_in">rd</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) ans[i]=n+<span class="hljs-number">1</span>-i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,u,v; i&lt;=m; i++)<br>&#123;<br>u=<span class="hljs-built_in">rd</span>(); v=<span class="hljs-built_in">rd</span>();<br>g[u].<span class="hljs-built_in">push_back</span>(v); g[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">sort</span>(g[i].<span class="hljs-built_in">begin</span>(),g[i].<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">if</span>(m&lt;n) &#123; <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>); <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=nr; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,r[i]); &#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">work2</span>(); <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i]); &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>还没补..</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题面：-3"><a href="#题面：-3" class="headerlink" title="题面："></a>题面：</h3><p>有向图，边权非负，$1 \le n \le 10^5,1 \le m \le 2\times 10^5,1 \le k \le 50$，$1$ 号点到 $n$ 号点的最短路长为 $d$，求$1$ 号点到 $N$ 号点长度不超过 $d + K$ 的路径个数</p><h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><p>考虑 dp ，由于 $k$ 很小，把 $k$ 设为状态.</p><p>设 $dis_u$  表示 $1\rightarrow u$ 最短路</p><p>$f_{u,j}$ 表示 $1\rightarrow u$ 等于 $dis_u+j$ 的路径个数</p><p>使用 dijkstra+堆求出 $dis_u$ ，再使用记忆化搜索转移 $f$</p><p>dp 时记录当前正在被 dp 的 $f_{u,j}$ ，如果再次 dp 到了，说明出现了零环，输出 -1</p><h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, inf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> n,m,k,P,flag;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> v,w; &#125;;<br>vector&lt;edge&gt; g[N],h[N];<br><span class="hljs-type">int</span> vt[N],dis[N];<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">56</span>],vf[N][<span class="hljs-number">56</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijk</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; pq;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) dis[i]=inf;<br>    dis[s]=<span class="hljs-number">0</span>; pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">-0</span>,s&#125;);<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())<br>&#123;<br>        <span class="hljs-keyword">auto</span> now=pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> val=now.first,u=now.second;<br>        <span class="hljs-keyword">if</span>(dis[u]&lt;val) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:g[u])<br>&#123;<br>            <span class="hljs-keyword">if</span>(dis[e.v]&gt;dis[u]+e.w)<br>&#123;<br>                dis[e.v]=dis[u]+e.w;<br>                pq.<span class="hljs-built_in">push</span>(&#123;-dis[e.v],e.v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(~f[u][j]) <span class="hljs-keyword">return</span> f[u][j];<br>f[u][j]=<span class="hljs-number">0</span>,vf[u][j]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:h[u])<br>&#123;<br><span class="hljs-type">int</span> t=dis[u]-dis[e.v]+j-e.w;<br><span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(vf[e.v][t]) flag=<span class="hljs-number">1</span>;<br>f[u][j]=(f[u][j]+<span class="hljs-built_in">dp</span>(e.v,t))%P;<br>&#125;<br>vf[u][j]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> f[u][j];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> T; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);<br><span class="hljs-keyword">while</span>(T--)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;P);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) g[i].<span class="hljs-built_in">clear</span>(),h[i].<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,u,v,w; i&lt;=m; i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);<br>g[u].<span class="hljs-built_in">push_back</span>(&#123;v,w&#125;),h[v].<span class="hljs-built_in">push_back</span>(&#123;u,w&#125;);<br>&#125;<br><span class="hljs-built_in">dijk</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(f)); flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=k; i++) <span class="hljs-built_in">dp</span>(n,i);<br><span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(f)); f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=k; i++) ans=(ans+<span class="hljs-built_in">dp</span>(n,i))%P;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>图论</tag>
      
      <tag>欧拉路</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>基环树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>洛谷 P7473 [NOI Online 2021 入门组] 重力球</title>
    <link href="/2022/11/01/%E6%B4%9B%E8%B0%B7-P7473-NOI-Online-2021-%E5%85%A5%E9%97%A8%E7%BB%84-%E9%87%8D%E5%8A%9B%E7%90%83/"/>
    <url>/2022/11/01/%E6%B4%9B%E8%B0%B7-P7473-NOI-Online-2021-%E5%85%A5%E9%97%A8%E7%BB%84-%E9%87%8D%E5%8A%9B%E7%90%83/</url>
    
    <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>题目链接：<a href="https://www.luogu.com.cn/problem/P7473">https://www.luogu.com.cn/problem/P7473</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先这题放在图论专题难度就下降了一大个档次ww</p><p>我们注意到一点，就是如果你可以把两个点的位置记下来，一步操作之后，只会有四种可能的情况.</p><p>两个点的位置情况乍一看是 $n^4\approx 3.9\times10^9$ 存不下，但是注意到一步操作之后，一定会在障碍点四周四个点或者边界上.</p><p>所以情况数只有 $(4m+4n)^2&#x3D;4\times10^6$，完全可以接受.</p><p>然后我们的思路就是先预处理出所有点移动一步可能的位置，建图，bfs 求出每个点最小的步数，然后回答询问的时候枚举一下第一步的情况.</p><p><strong>小常识：边权为1的图的最短路可以用bfs $O(n)$ 求</strong></p><p><strong>到多个点的最小步数直接把所有终点塞进去bfs就好了</strong> </p><p>时间复杂度 $O((4m+4n)^2+q)$</p><p>呃这个代码实现不太好写（我的码力问题</p><h2 id="实现上的小细节"><a href="#实现上的小细节" class="headerlink" title="实现上的小细节"></a>实现上的小细节</h2><p>记得建的是反边，回答询问的时候记得特判两个点最开始是否已经重合.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">255</span>, M = <span class="hljs-number">4e6</span>+<span class="hljs-number">5</span>, inf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> n,m,q,np;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span> <br>&#123; <br><span class="hljs-type">int</span> x,y;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d,%d)&quot;</span>,x,y); &#125;<br><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> point &amp;a, <span class="hljs-type">const</span> point &amp;b) &#123; <span class="hljs-keyword">return</span> a.x&lt;b.x <span class="hljs-built_in">or</span> (a.x==b.x <span class="hljs-keyword">and</span> a.y&lt;b.y); &#125;<br><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> point &amp;a, <span class="hljs-type">const</span> point &amp;b) &#123;<span class="hljs-keyword">return</span> a.x==b.x <span class="hljs-keyword">and</span> a.y==b.y; &#125; <br><span class="hljs-keyword">friend</span> point <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> point &amp;a, <span class="hljs-type">const</span> point &amp;b) &#123; <span class="hljs-keyword">return</span> &#123;a.x+b.x,a.y+b.y&#125;; &#125; <br><span class="hljs-keyword">friend</span> point <span class="hljs-keyword">operator</span>- (<span class="hljs-type">const</span> point &amp;a, <span class="hljs-type">const</span> point &amp;b) &#123; <span class="hljs-keyword">return</span> &#123;a.x-b.x,a.y-b.y&#125;; &#125; <br>&#125; p[N&lt;&lt;<span class="hljs-number">3</span>];<br><br><span class="hljs-type">int</span> a[N][N][<span class="hljs-number">4</span>],dis[M],mp[N][N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">p_to_q</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (x<span class="hljs-number">-1</span>)*np+y; &#125;<br><span class="hljs-type">int</span> head[M],nxt[M&lt;&lt;<span class="hljs-number">4</span>],ver[M&lt;&lt;<span class="hljs-number">4</span>],tot;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; ver[++tot]=y; nxt[tot]=head[x]; head[x]=tot; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//init p</span><br><span class="hljs-type">static</span> point obs[N],dir[]=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> vt[N][N];<br><span class="hljs-keyword">auto</span> check=[&amp;](point t) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;=t.x <span class="hljs-keyword">and</span> t.x&lt;=n <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>&lt;=t.y <span class="hljs-keyword">and</span> t.y&lt;=n <span class="hljs-keyword">and</span> !vt[t.x][t.y]; &#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) obs[i].<span class="hljs-built_in">rd</span>(),vt[obs[i].x][obs[i].y]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(&#123;<span class="hljs-number">1</span>,i&#125;)) p[++np]=&#123;<span class="hljs-number">1</span>,i&#125;;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(&#123;n,i&#125;)) p[++np]=&#123;n,i&#125;;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(&#123;i,<span class="hljs-number">1</span>&#125;)) p[++np]=&#123;i,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(&#123;i,n&#125;)) p[++np]=&#123;i,n&#125;;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">4</span>; j++)<br>&#123;<br>point t=obs[i]+dir[j];<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(t)) p[++np]=t;<br>&#125;<br><span class="hljs-built_in">sort</span>(p+<span class="hljs-number">1</span>,p+np+<span class="hljs-number">1</span>); np=<span class="hljs-built_in">unique</span>(p+<span class="hljs-number">1</span>,p+np+<span class="hljs-number">1</span>)-p<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=np; i++) mp[p[i].x][p[i].y]=i;<br><span class="hljs-comment">//init a</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++) <br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(&#123;i,j&#125;)) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;<span class="hljs-number">4</span>; k++)<br>&#123;<br>point c=&#123;i,j&#125;;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">check</span>(c+dir[k])) c=c+dir[k];<br>a[i][j][k]=mp[c.x][c.y];<br>&#125;<br><span class="hljs-comment">//init q</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=np; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=np; j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;<span class="hljs-number">4</span>; k++)<br>&#123;<br><span class="hljs-type">int</span> u=<span class="hljs-built_in">p_to_q</span>(i,j); <br><span class="hljs-type">int</span> v=<span class="hljs-built_in">p_to_q</span>(a[p[i].x][p[i].y][k],a[p[j].x][p[j].y][k]);<br><span class="hljs-built_in">add</span>(v,u);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work_dist</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> vis[M];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=np*np; i++) dis[i]=inf;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=np; i++) &#123; <span class="hljs-type">int</span> t=<span class="hljs-built_in">p_to_q</span>(i,i); q.<span class="hljs-built_in">push</span>(t); dis[t]=<span class="hljs-number">0</span>; vis[t]=<span class="hljs-number">1</span>; &#125;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=head[u]; j; j=nxt[j])<br>&#123;<br><span class="hljs-type">int</span> v=ver[j]; <br><span class="hljs-keyword">if</span>(!vis[v]) dis[v]=<span class="hljs-built_in">min</span>(dis[v],dis[u]+<span class="hljs-number">1</span>),vis[v]=<span class="hljs-number">1</span>,q.<span class="hljs-built_in">push</span>(v);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">answer_query</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>point S,T;<br><span class="hljs-keyword">while</span>(q--)<br>&#123;<br>S.<span class="hljs-built_in">rd</span>(); T.<span class="hljs-built_in">rd</span>(); <span class="hljs-type">int</span> res=inf;<br><span class="hljs-keyword">if</span>(S==T) res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mp[S.x][S.y] <span class="hljs-keyword">and</span> mp[T.x][T.y]) res=dis[<span class="hljs-built_in">p_to_q</span>(mp[S.x][S.y],mp[T.x][T.y])];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">4</span>; j++) res=<span class="hljs-built_in">min</span>(res,<span class="hljs-number">1</span>+dis[<span class="hljs-built_in">p_to_q</span>(a[S.x][S.y][j],a[T.x][T.y][j])]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res&gt;=inf?<span class="hljs-number">-1</span>:res);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br><span class="hljs-built_in">init</span>(); <span class="hljs-built_in">work_dist</span>(); <span class="hljs-built_in">answer_query</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>bfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DTOJ 5093 淘淘种地 题解</title>
    <link href="/2022/10/31/DTOJ-5093-%E6%B7%98%E6%B7%98%E7%A7%8D%E5%9C%B0-%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/10/31/DTOJ-5093-%E6%B7%98%E6%B7%98%E7%A7%8D%E5%9C%B0-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>题目链接：<a href="http://59.61.75.5:8018/p/P5093">http://59.61.75.5:8018/p/P5093</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这个是CSP前最后一场测试的 T2，打的不是很好，没有想到这题正解，但是这题暴力分很多ww</p><p>二进制拆位的思想要有（（</p><h2 id="30分"><a href="#30分" class="headerlink" title="30分"></a>30分</h2><p>暴力模拟 $O(nmT)$</p><h2 id="70分"><a href="#70分" class="headerlink" title="70分"></a>70分</h2><p>满足 $1 \leq a[i][j], k[i] \leq 2$</p><p>对每种肥料做一遍前缀和，得出每个点被哪些种类覆盖. $O(T+nm)$. 因为只有两种所以很可做.</p><h2 id="100分"><a href="#100分" class="headerlink" title="100分"></a>100分</h2><p>部分分启发我们二进制拆位（虽然测试的时候没启发到我）</p><p>总之拆位.</p><p>对每一位的 $0$ 和 $1$ 分别做一遍前缀和，最后如果与 $a[i][j]$ 不同的位上有肥料，他就安详地去世了.</p><p>效率就是$O((T+nm)\log nm)$</p><p>然后你会发现你 <code>RE</code> <code>MLE</code> 了</p><h3 id="实现要注意："><a href="#实现要注意：" class="headerlink" title="实现要注意："></a>实现要注意：</h3><p>不要用 vector，空间真的很容易炸</p><p>把二维数组压成一位数组</p><p>把枚举位数的循环扔外面，数组可以少一位</p><p>然后你就快乐 <code>AC</code> 了</p><p>（当然这题有别的做法，什么树状数组之类的</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n,m,T;<br><span class="hljs-type">int</span> a[N&lt;&lt;<span class="hljs-number">2</span>],d[<span class="hljs-number">2</span>][N&lt;&lt;<span class="hljs-number">2</span>],xa[N],ya[N],xb[N],yb[N],k[N],ans[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> i*(m+<span class="hljs-number">3</span>)+j; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;T);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[<span class="hljs-built_in">f</span>(i,j)]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++) ans[<span class="hljs-built_in">f</span>(i,j)]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=T; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d&quot;</span>,&amp;xa[i],&amp;ya[i],&amp;xb[i],&amp;yb[i],&amp;k[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>; c&lt;<span class="hljs-number">22</span>; c++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>; t&lt;=<span class="hljs-number">1</span>; t++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n+<span class="hljs-number">1</span>; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=m+<span class="hljs-number">1</span>; j++) d[t][<span class="hljs-built_in">f</span>(i,j)]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=T; i++)<br>&#123;<br>d[(k[i]&gt;&gt;c)&amp;<span class="hljs-number">1</span>][<span class="hljs-built_in">f</span>(xa[i],ya[i])]++;<br>d[(k[i]&gt;&gt;c)&amp;<span class="hljs-number">1</span>][<span class="hljs-built_in">f</span>(xb[i]+<span class="hljs-number">1</span>,yb[i]+<span class="hljs-number">1</span>)]++;<br>d[(k[i]&gt;&gt;c)&amp;<span class="hljs-number">1</span>][<span class="hljs-built_in">f</span>(xa[i],yb[i]+<span class="hljs-number">1</span>)]--;<br>d[(k[i]&gt;&gt;c)&amp;<span class="hljs-number">1</span>][<span class="hljs-built_in">f</span>(xb[i]+<span class="hljs-number">1</span>,ya[i])]--;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>; t&lt;=<span class="hljs-number">1</span>; t++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++)<br>d[t][<span class="hljs-built_in">f</span>(i,j)]+=d[t][<span class="hljs-built_in">f</span>(i,j<span class="hljs-number">-1</span>)]+d[t][<span class="hljs-built_in">f</span>(i<span class="hljs-number">-1</span>,j)]-d[t][<span class="hljs-built_in">f</span>(i<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>)];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++)<br>&#123;<br><span class="hljs-type">int</span> t=(a[<span class="hljs-built_in">f</span>(i,j)]&gt;&gt;c)&amp;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(d[t^<span class="hljs-number">1</span>][<span class="hljs-built_in">f</span>(i,j)]&gt;<span class="hljs-number">0</span>) ans[<span class="hljs-built_in">f</span>(i,j)]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++) <span class="hljs-keyword">if</span>(!ans[<span class="hljs-built_in">f</span>(i,j)]) cnt++;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,cnt);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二进制拆位</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DTOJ 2485 COCI2015 Kamp 题解</title>
    <link href="/2022/10/31/DTOJ-2485-COCI2015-Kamp-%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/10/31/DTOJ-2485-COCI2015-Kamp-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p><a href="http://59.61.75.5:8018/p/P2485">http://59.61.75.5:8018/p/P2485</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>典型的换根 dp 题，一直没去写，今天补完了.</p><p>首先我们考虑如果从 $1$ 号节点开始怎么做</p><p>注意到如果需要回到根节点，答案是好维护的.</p><p>记 $f_u$ 表示从 $u$ 出发，走完所有 $u$ 子树内的点，回到 $u$ 的最小路程.</p><p>那么不需要回到根节点的答案就是 $ans_u&#x3D;f_u-\max{d_u}$ ，$d_u$ 是 $u$ 到 $1$ 的距离</p><p>状态转移也是容易的<br>$$<br>f_u&#x3D;\sum_{f_v&gt;0\or v\in S}(f_v+2w_{u,v})\<br>mx_u&#x3D;\max{mx_v+w_{u,v}}\<br>$$<br>（ $mx_u$ 表示 $\max{d_u}$ , $S$ 表示 $k$ 个特殊点的集合）</p><p>考虑如何换根 dp</p><p>$f_u$ 是好换根的<br>$$<br>f_u’&#x3D;f_u-(f_v+2w_{u,v})\<br>f_v’&#x3D;f_v+(f_u’+2w_{u,v})<br>$$<br>（注意要判子树里有没有点）</p><p>$mx_u$ 比较难换根，需要再维护一个次大值.</p><p>我直接全部存起来了（这做法不太好，容易导致 CSP T1 炸掉）</p><p>维护方法看代码</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fs first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n,k,tg[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> v,w; &#125;;<br>vector&lt;edge&gt; g[N];<br>ll ans[N],f[N]; <br>set&lt;pair&lt;ll,<span class="hljs-type">int</span>&gt; &gt; d[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">mx</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123; <span class="hljs-built_in">assert</span>(d[u].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>); <span class="hljs-keyword">return</span> (*d[u].<span class="hljs-built_in">rbegin</span>()).fs; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> prv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(tg[u]) d[u].<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">0ll</span>,u&#125;);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:g[u])<br>&#123;<br><span class="hljs-keyword">if</span>(e.v==prv) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs1</span>(e.v,u);<br><span class="hljs-keyword">if</span>(f[e.v] <span class="hljs-keyword">or</span> tg[e.v]) f[u]+=f[e.v]+e.w*<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(d[e.v].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>) d[u].<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">mx</span>(e.v)+e.w,e.v&#125;);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> prv)</span></span><br><span class="hljs-function"></span>&#123;<br>ans[u]=f[u]-<span class="hljs-built_in">mx</span>(u);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:g[u])<br>&#123;<br><span class="hljs-type">int</span> v=e.v;<br><span class="hljs-keyword">if</span>(v==prv) <span class="hljs-keyword">continue</span>;<br>ll fu=f[u]-((f[v] <span class="hljs-keyword">or</span> tg[v])?f[v]+<span class="hljs-number">2</span>*e.w:<span class="hljs-number">0</span>);<br>ll fv=f[v]+((fu <span class="hljs-keyword">or</span> tg[u])?fu+<span class="hljs-number">2</span>*e.w:<span class="hljs-number">0</span>);<br>ll tmpv;<br><span class="hljs-keyword">if</span>(d[u].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) tmpv=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((*d[u].<span class="hljs-built_in">rbegin</span>()).sc==v) tmpv=(d[u].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)?e.w+(*(++d[u].<span class="hljs-built_in">rbegin</span>())).fs:<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> tmpv=<span class="hljs-built_in">mx</span>(u)+e.w;<br>ll tmpu=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(d[v].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>) tmpu=<span class="hljs-built_in">mx</span>(v)+e.w;<br><span class="hljs-keyword">if</span>(tmpv&gt;=<span class="hljs-number">0</span>) d[v].<span class="hljs-built_in">insert</span>(&#123;tmpv,u&#125;); <span class="hljs-keyword">if</span>(tmpu&gt;=<span class="hljs-number">0</span>) d[u].<span class="hljs-built_in">erase</span>(&#123;tmpu,v&#125;);<br><span class="hljs-built_in">swap</span>(f[u],fu),<span class="hljs-built_in">swap</span>(f[v],fv);<br><span class="hljs-built_in">dfs2</span>(e.v,u);<br><span class="hljs-built_in">swap</span>(f[u],fu),<span class="hljs-built_in">swap</span>(f[v],fv);<br><span class="hljs-keyword">if</span>(tmpv&gt;=<span class="hljs-number">0</span>) d[v].<span class="hljs-built_in">erase</span>(&#123;tmpv,u&#125;); <span class="hljs-keyword">if</span>(tmpu&gt;=<span class="hljs-number">0</span>) d[u].<span class="hljs-built_in">insert</span>(&#123;tmpu,v&#125;);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,u,v,w; i&lt;n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w),g[u].<span class="hljs-built_in">push_back</span>(&#123;v,w&#125;),g[v].<span class="hljs-built_in">push_back</span>(&#123;u,w&#125;);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,u; i&lt;=k; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;u),tg[u]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>换根dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DTOJ 3498 无限剑制 题解</title>
    <link href="/2022/10/26/DTOJ-3498-%E6%97%A0%E9%99%90%E5%89%91%E5%88%B6-%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/10/26/DTOJ-3498-%E6%97%A0%E9%99%90%E5%89%91%E5%88%B6-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="DTOJ-3498-无限剑制-题解"><a href="#DTOJ-3498-无限剑制-题解" class="headerlink" title="DTOJ 3498 无限剑制 题解"></a>DTOJ 3498 无限剑制 题解</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>链接：<a href="http://59.61.75.5:8018/p/P3498">http://59.61.75.5:8018/p/P3498</a></p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>​*<strong>I am the bone of my sword.*</strong> </p><p>​*<strong>体は剣で出来ている.*</strong> </p><p>​*<strong>Steel is my body, and fire is my blood.*</strong> </p><p>​*<strong>血潮は鉄で 心は硝子.*</strong> </p><p>​*<strong>I have created over a thousand blades.*</strong> </p><p>​*<strong>几たびの戦场を越えて不败.*</strong> </p><p>​*<strong>Unknown to Death.*</strong> </p><p>​*<strong>ただの一度も败走はなく.*</strong> </p><p>​*<strong>Nor known to Life.*</strong> </p><p>​*<strong>ただの一度も理解されない.*</strong> </p><p>​*<strong>Have withstood pain to create many weapons.*</strong> </p><p>​*<strong>彼の者は常に独り 剣の丘で胜利に酔う.*</strong> </p><p>​*<strong>Yet, those hands will never hold anything.*</strong> </p><p>​*<strong>故に、生涯に意味はなく.*</strong> </p><p>​*<strong>So as I pray, Unlimited Blade Works.*</strong> </p><p>​*<strong>その体は、きっと剣で出来ていた.*</strong> </p><p>​<strong>“无限剑制”</strong> </p><p>​<strong>等级：E~A＋＋</strong> </p><p>​<strong>种类：？？</strong> </p><p>​<strong>Unlimited Blade Works。</strong> </p><p>​<strong>被称为固有结界的特殊魔术。</strong> </p><p>​<strong>在一定时间内，将现实改写为心象世界，至今为止术者见过并能够认知的武器、在这个地方使用过的武器都能瞬间复制、保存。</strong> </p><p>​<strong>但是，复制的武器等级会下降一级。</strong> </p><p>​ </p><p>​Emiya打算增加自己固有结界内的武器数量。他初始有 $ 5 $ 把武器，编号为 $ 1-5 $ ,每把武器有 $ n(n \le 10^5) $ 个属性数值 $ v_i $ 。Emiya接着制作 $ m $ 把新武器，第 $ i $ 次会选择编号为 $ a_i,b_i $ 的武器为模板投影出一把新的武器，新的武器的编号为 $ 5+i $ ，每一个属性的值为两个模板武器对应属性的值的 $ max $ 或 $ min $ 。同时Emiya想知道新的武器的第 $ k_i $ 个属性的数值。但是Emiya还要去做饭，所以需要他的master你来回答这些问题。 </p><h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>​第 $ 1 $ 行两个正整数 $ n,m $ 。 </p><p>​第 $ 2 $ 到 $ 6 $ 行，每行 $ n $ 个正整数，第 $ i $ 个数表示 $ v_i $ 。 </p><p>​第 $ 7 $ 到 $ 6+m $ 行，每行 $ 4 $ 个数 $ p_i,a_i,b_i,k_i $ ，其中模板武器为 $ a_i,b_i $ ， $ p_i&#x3D;0 $ 为 $ min $ ， $ p_i&#x3D;1 $ 为 $ max $ ，查询第 $ k_i $ 个属性的数值。 </p><h3 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h3><p>​ $ m $ 行，每行 $ 1 $ 个整数，表示第 $ k_i $ 个属性的数值 </p><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">6 3<br>1 5 9 3 8 6 <br>4 1 1 4 9 3 <br>8 7 7 8 10 8 <br>9 8 6 9 3 4 <br>5 3 4 1 1 2 <br>0 2 5 6<br>0 4 3 6<br>1 7 4 1<br></code></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br>4<br>9<br></code></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>​保证对于每一个属性，初始 $ 5 $ 把武器该属性的数值不同。 </p><p>​ $ 10 % $ ： $ n \le 10^3,m \le 10^3 $ 。 </p><p>​另外 $ 20 % $ ： $ m \le 5 \times 10^3 $  </p><p>​另外 $ 20 % $ ： $ a_i \le 5,b_i $ 随机生成 </p><p>​另外 $ 20 % $ ：所有 $ v_i $ 值域在 $ [1,5] $  </p><p>​ $ 100 % $ ： $ k_i \le n \le 10^5,m \le 10^5,a_i,b_i \le 4+i,v_i \le 10^9 $ </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>想了好久，其实很水tt</p><p>想写题解主要是因为这题题面是 Fate 很有意思</p><p>我们注意到 “所有 $ v_i $ 值域在 $ [1,5] $” 这个部分分，这种情况下，初始的不同情况数只有 $5!&#x3D;120$ 种，可以直接暴力做</p><p>没有这个限制直接离散化就好了.</p><p>所以最终做法就是：对每一位分别考虑，发现离散化后只有 $5!&#x3D;120$ 种不同情况，然后对 $120$ 种情况都暴力进行 <strong>Unlimited Blade Works</strong> ，然后回答询问，时间复杂度 $\Theta(5!\cdot m)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> fc[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">24</span>,<span class="hljs-number">120</span>,<span class="hljs-number">720</span>&#125;;<br><span class="hljs-type">int</span> n,m,v[N][<span class="hljs-number">6</span>],w[N][<span class="hljs-number">6</span>],p[<span class="hljs-number">125</span>][<span class="hljs-number">6</span>],r[<span class="hljs-number">125</span>][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">perm_to_id</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">5</span>; j++) <span class="hljs-keyword">if</span>(w[k][j]&lt;w[k][i]) cnt++;<br>ans+=cnt*fc[<span class="hljs-number">5</span>-i];<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) p[<span class="hljs-number">1</span>][i]=i;<br><span class="hljs-type">int</span> c=<span class="hljs-number">1</span>; <span class="hljs-keyword">do</span> &#123; c++; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) p[c][i]=p[c<span class="hljs-number">-1</span>][i]; &#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(p[c]+<span class="hljs-number">1</span>,p[c]+<span class="hljs-number">6</span>)); c--;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=c; j++) r[j][i]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">5</span>; j++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;v[i][j]);<br><span class="hljs-type">int</span> d[<span class="hljs-number">6</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">5</span>; j++) d[j]=j;<br><span class="hljs-built_in">sort</span>(d+<span class="hljs-number">1</span>,d+<span class="hljs-number">6</span>,[&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y)&#123; <span class="hljs-keyword">return</span> v[i][x]&lt;v[i][y] <span class="hljs-built_in">or</span> (v[i][x]==v[i][y] <span class="hljs-keyword">and</span> x&lt;y); &#125;);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">5</span>; j++) w[i][d[j]]=j;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">6</span>; j&lt;=m+<span class="hljs-number">5</span>; j++)<br>&#123;<br><span class="hljs-type">int</span> op,a,b,k; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;op,&amp;a,&amp;b,&amp;k);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=c; i++)<br><span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) r[i][j]=(p[i][r[i][a]]&lt;p[i][r[i][b]])?r[i][b]:r[i][a];<br><span class="hljs-keyword">else</span> r[i][j]=(p[i][r[i][a]]&gt;p[i][r[i][b]])?r[i][b]:r[i][a];<br><span class="hljs-type">int</span> pn=<span class="hljs-built_in">perm_to_id</span>(k)+<span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,v[k][r[pn][j]]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这边用了 Cantor 展开求排列的顺序，也可以用哈希写.</p>]]></content>
    
    
    
    <tags>
      
      <tag>思维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DTOJ 6316 沙丘 题解</title>
    <link href="/2022/10/24/DTOJ-6316-%E6%B2%99%E4%B8%98-%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/10/24/DTOJ-6316-%E6%B2%99%E4%B8%98-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="DTOJ-6316-沙丘-题解"><a href="#DTOJ-6316-沙丘-题解" class="headerlink" title="DTOJ 6316 沙丘 题解"></a>DTOJ 6316 沙丘 题解</h1><h4 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h4><p><a href="http://59.61.75.5:8018/p/P6316">http://59.61.75.5:8018/p/P6316</a></p><p>在满天的星光下，灰大狼一人孤独地堆起了小沙丘。有 $n$ 堆沙丘，每堆沙丘有相对高度 $h_i$，每次灰大狼可以选择一段连续的沙丘并将它们高度增加或减少 $a$ 或 $b$，其中 $a,b$ 给定，灰大狼想知道最少要几次才能把所有沙丘的相对高度都变成 $0$。如果无解请输出 <code>-1</code>。</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>首先看到是 “一段连续的沙丘”，果断考虑差分. </p><p>差分完增加或减小 $a$ 或 $b$ 可以被转化成两个位置上分别  $+a, -a$  或 $+b, -b$  </p><p>最后每个位置上一定是 $xa+yb$ 的形式，记差分数组为 ${d_i}$，则 $xa+yb&#x3D;d_i$ </p><p>显然是可以 exgcd 求出一组特解 $x_0,y_0$</p><p>于是通解可以表示成 $\begin{cases}x&#x3D;x_0+\frac{b}{\gcd(a,b)}\cdot k\ y&#x3D;y_0-\frac{a}{\gcd(a,b)}\cdot k\end{cases}$</p><p>最后答案即 $\frac{1}{2}\sum(|x|+|y|)$</p><p>测试的时候我直接调整每个 $x,y$ 使 $|x|+|y|$ 最小. </p><p>$|x|+|y|&#x3D;|x_0+\frac{b}{\gcd(a,b)}\cdot k|+ |y_0-\frac{a}{\gcd(a,b)}\cdot k|$</p><p>根据高一数学，这一定是三个一次函数组成的分段函数.</p><p>于是最小值一定只有四种情况， $x$ 最小正值，$x$ 最大负值， $y$ 最小正值，$y$ 最大负值.</p><p>但是我们发现这么做有个问题，就是差分数组要满足  $\sum x &#x3D; 0$ 且 $\sum y &#x3D; 0$</p><blockquote><p>上次数竞比赛也是没注意到限制条件少了50分ww</p></blockquote><p>考虑继续调整，注意到 $\sum x &#x3D;0 \Rightarrow \sum y &#x3D;0$ 所以只需要调整  $\sum x &#x3D; 0$ </p><p>不妨设 $\sum x &gt; 0$ 我们对于一个位置 $i$，若 $\sum x$ 变化 $1$， 则 $|x|+|y|$ 变化 $|x-\frac{b}{gcd(a,b)}|-|x|$</p><p>把所有的变化存进堆里，从小到大取出来. </p><p>嗯这就做完了 $(\and \omega\and)$</p><p>代码好难写（码力不够</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x,f=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch=<span class="hljs-built_in">getchar</span>())) <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(x=(ch^<span class="hljs-number">48</span>); <span class="hljs-built_in">isdigit</span>(ch=<span class="hljs-built_in">getchar</span>()); x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>));<br><span class="hljs-keyword">return</span> f?-x:x;<br>&#125;<br><span class="hljs-type">int</span> n,a,b,c[N],x[N],y[N];<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; Q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(!b) &#123; x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<br><span class="hljs-type">int</span> d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x); y-=(a/b)*x;<br><span class="hljs-keyword">return</span> d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>n=<span class="hljs-built_in">rd</span>(),a=<span class="hljs-built_in">rd</span>(),b=<span class="hljs-built_in">rd</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) c[i]=<span class="hljs-built_in">rd</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=++n; i; --i) c[i]=c[i]-c[i<span class="hljs-number">-1</span>];<br><span class="hljs-type">int</span> tx,ty,d=<span class="hljs-built_in">exgcd</span>(a,b,tx,ty); a/=d,b/=d;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(c[i]%d) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br><span class="hljs-type">int</span> X=((ll)tx*c[i]/d%b+b)%b,Y=(c[i]/d-(ll)a*X)/b;<br>x[i]=X,y[i]=Y;<br>X-=b,Y+=a;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(X)+<span class="hljs-built_in">abs</span>(Y)&lt;<span class="hljs-built_in">abs</span>(x[i])+<span class="hljs-built_in">abs</span>(y[i])) x[i]=X,y[i]=Y;<br>Y=((ll)ty*c[i]/d%a+a)%a,X=(c[i]/d-(ll)b*Y)/a;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(X)+<span class="hljs-built_in">abs</span>(Y)&lt;<span class="hljs-built_in">abs</span>(x[i])+<span class="hljs-built_in">abs</span>(y[i])) x[i]=X,y[i]=Y;<br>Y-=a,X+=b;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(X)+<span class="hljs-built_in">abs</span>(Y)&lt;<span class="hljs-built_in">abs</span>(x[i])+<span class="hljs-built_in">abs</span>(y[i])) x[i]=X,y[i]=Y;<br>&#125;<br>ll s=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) s+=x[i];<br>s/=b;<br><span class="hljs-keyword">if</span>(s&lt;<span class="hljs-number">0</span>) s=-s,<span class="hljs-built_in">swap</span>(a,b),<span class="hljs-built_in">swap</span>(x,y);<br><span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;p)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(x[p]-b)+<span class="hljs-built_in">abs</span>(y[p]+a)-<span class="hljs-built_in">abs</span>(x[p])-<span class="hljs-built_in">abs</span>(y[p]); &#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(-<span class="hljs-built_in">f</span>(i),i));<br><span class="hljs-keyword">while</span>(s--)<br>&#123;<br><span class="hljs-type">int</span> p=Q.<span class="hljs-built_in">top</span>().second; Q.<span class="hljs-built_in">pop</span>();<br>x[p]-=b,y[p]+=a;<br>Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(-<span class="hljs-built_in">f</span>(p),p));<br>&#125;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) ans+=<span class="hljs-built_in">abs</span>(x[i])+<span class="hljs-built_in">abs</span>(y[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans/<span class="hljs-number">2</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>差分</tag>
      
      <tag>exgcd</tag>
      
      <tag>贪心</tag>
      
      <tag>反悔贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DTOJ 5932 Counting 题解</title>
    <link href="/2022/10/22/DTOJ-5932-Counting-%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/10/22/DTOJ-5932-Counting-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="DTOJ-5932-Counting-题解"><a href="#DTOJ-5932-Counting-题解" class="headerlink" title="DTOJ 5932 Counting 题解"></a>DTOJ 5932 Counting 题解</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://59.61.75.5:8018/p/P5932">http://59.61.75.5:8018/p/P5932</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>认识到了生成函数很好用，于是摆了一篇题解</p><h3 id="10分"><a href="#10分" class="headerlink" title="10分"></a>10分</h3><p>直接dp，$f_{i,j}$ 表示走了 $i$ 步之后，当前位置在  $j$ 的方案数</p><p>然后就有状态转移方程 $f_{i,j}&#x3D;f_{i-1,j-1}+f_{i-1,j}+f_{i-1,j+1}$</p><p>时间复杂度 $\Theta(nm)$</p><h3 id="40-50分"><a href="#40-50分" class="headerlink" title="40~50分"></a>40~50分</h3><p>相信大家都会矩阵快速幂<br>$$<br>\begin {bmatrix}<br>1 &amp; 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0\<br>1 &amp; 1 &amp; 1 &amp; 0 &amp; \cdots &amp; 0\<br>0 &amp; 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 0\<br>0 &amp; 0 &amp; 1 &amp; 1 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1<br>\end {bmatrix}<br>\begin {bmatrix}<br>f_{i-1,0} \<br>f_{i-1,1} \<br>f_{i-1,2} \<br>f_{i-1,3} \<br>\vdots  \<br>f_{i-1,n-1} \<br>\end {bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>f_{i,0} \<br>f_{i,1} \<br>f_{i,2} \<br>f_{i,3} \<br>\vdots  \<br>f_{i,n-1} \<br>\end{bmatrix}<br>$$</p><h3 id="80-90分"><a href="#80-90分" class="headerlink" title="80~90分"></a>80~90分</h3><p>相信大家都学过 Catalan 数</p><p>我们先枚举走的 $n $ 步中，有 $k$ 次是移动，$n-k$ 次是原地不动，有 $\binom{n}{k}$ 种方法</p><p>把向左移动记为 $(1,1)$，向右移动记为 $(1,-1)$，则可以表示成下图这样</p><p><img src="/%22/img/post_img/DTOJ_5932_pic1.png%22"></p><p>这边比 Catalan 数那个图多了一条线，于是我们考虑容斥，可以得到：</p><p>方案数 $&#x3D;$ 总路径数 </p><p>$-$ 越过 $y&#x3D;m$ 的路径数 $-$ 越过 $y&#x3D;0$ 的路径数 </p><p>$+$ 先越过 $y&#x3D;0$ 再越过 $y&#x3D;m$ 的路径数 $+$ 先越过 $y&#x3D;m$ 再越过$y&#x3D;0$ 的路径数 </p><p>$-$ 越过 $3$ 次的路径数 </p><p>$+$ … </p><p>所以可以把终点 $(k,0)$ 关于 $y&#x3D;0$ 和 $y&#x3D;m$ 交替对称，加上或者减去到每个点的路径数</p><p> $(k,0) \rightarrow (k,-2) \rightarrow (k,2m+4) \rightarrow (k,-2m-6) \rightarrow\dots$</p><p> $(k,0) \rightarrow (k,2m+2) \rightarrow (k,-2m-4) \rightarrow (k,4m+6) \rightarrow\dots$</p><p>于是可以写出组合式子<br>$$<br>ans&#x3D;\sum_{k&#x3D;0}^n\binom{n}{k}\left(\left(\binom{k}{k&#x2F;2}-\binom{k}{k&#x2F;2-1}+\binom{k}{k&#x2F;2+m+2}-\dots\right)+\left(\binom{k}{k&#x2F;2}-\binom{k}{k&#x2F;2-1}+\binom{k}{k&#x2F;2+m+2}-\dots\right)\right)<br>$$<br>因为最多可以越过$\frac{n}{m}$ 条线，所以时间复杂度是 $\Theta(\frac{n^2}{m})$</p><h3 id="100分"><a href="#100分" class="headerlink" title="100分"></a>100分</h3><p>可以发现dp式子可以写成卷积，于是考虑把式子改写成生成函数</p><p>$F_i(x)&#x3D;\left(\frac{1}{x}+1+x\right)F_{i-1}(x)$</p><p>则$F_n(x)&#x3D;\left(\frac{1}{x}+1+x\right)^n$</p><p>答案即为 $[x^0]F_n(x)&#x3D;[x^0]\left(\frac{1}{x}+1+x\right)^n&#x3D;[x^n]\left(1+x+x^2\right)^n$</p><p>记 $G&#x3D;1+x+x^2$  $H&#x3D;G^n$ </p><p>使用奇妙的小技巧（求导）：$H’&#x3D;nG^{n-1}G’$</p><p>同乘G得 $H’G&#x3D;nHG’$ </p><p>我们得到了一个好式子，就可以 $\Theta(n)$ 推出答案了</p><p>把 $H$ 和 $H’$ 写成展开形式： $H(x)&#x3D;\sum{h_ix^i}$   </p><p>$H’(x)&#x3D;\sum{ih_ix^i}&#x3D;\sum{(i+1)h_{i+1}x^i}$</p><p>又因为 $H’(x)(1+x+x^2)&#x3D;nH(x)(1+2x)$</p><p>求 $[x^k]$ 一项得 $<a href="(k+1)h_%7Bk+1%7D+kh_k+(k-1)h_%7Bk-1%7D">x^k</a>&#x3D;[x^k]n(h_k+2h_{k-1})$</p><p>整理得 $(k+1)h_{k+1}&#x3D;(n-k)h_k+(2n-k+1)h_{k-1}$</p><p>因为 $H&#x3D;(1+x+x^2)^n$ 所以 $h_0&#x3D;0, h_1&#x3D;n$ 就可以递推求得 $h_i$ 了呢（记得线性求逆元）</p><p>$h_i&#x3D;<a href="1+x+x%5E2">x^i</a>^n&#x3D;<a href="%5Cfrac%7B1%7D%7Bx%7D+1+x">x^{i-n}</a>^n$</p><p> 所以 $h_i$ 表示的就是 $n$ 步走到 $i-n$ 的方案数</p><p>浅浅地容斥一下就可以得到答案</p><p>时间复杂度是 $\Theta(n)$ 的</p><p>发现很好实现 我直呼好题</p>]]></content>
    
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>组合</tag>
      
      <tag>生成函数</tag>
      
      <tag>求导</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DTOJ 5769 下棋 题解</title>
    <link href="/2022/10/22/DTOJ-5769-%E4%B8%8B%E6%A3%8B-%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/10/22/DTOJ-5769-%E4%B8%8B%E6%A3%8B-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="DTOJ-5769-下棋-题解"><a href="#DTOJ-5769-下棋-题解" class="headerlink" title="DTOJ 5769 下棋 题解"></a>DTOJ 5769 下棋 题解</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://59.61.75.5:8018/p/P5769">http://59.61.75.5:8018/p/P5769</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先比较容易想到 $dp$ , 因为任意一段绝对值不超过 $k$ ，所以白棋个数减黑棋个数要在 $[-k,k]$ 区间里，我们于是考虑把状态设为白棋减黑棋个数的最大值和最小值. </p><p>具体来说 $f_{i,j,a,b}$ 表示用了 $i$ 个白，$j$ 个黑， 白减黑最大值和最小值分别为 $a,b$ .</p><p>转移较显然，时间复杂度 $O(n^2k^2)$</p><p>因为 $|i-j|\in[-k,k]$ 所以可以优化到 $O(nk^3)$ ，$f_{i,j,a,b}$ 的 $j$ 表示原来的 $i-j$</p><p>继续优化，考虑将白棋看做向上一步，黑棋看做向右一步，问题即可转化为求到 $(n,m)$ 的方案数，其中路径上点 $\max{x-y}-\min{x-y}\leq k$， 即路径在 $x-y&#x3D;k-t$ 和  $x-y&#x3D;-t$  $(t\in{0,1,…,k})$ 两条直线之间. 显然类似卡塔兰数的方格路径计数，因为两条线，需要容斥，时间复杂度 $O(nk)$. </p><p>由于 $\max{x-y}-\min{x-y} &lt; k$ 的答案会被算多次，需要减去路径在 $x-y&#x3D;(k-1)-t$ 和  $x-y&#x3D;-t$  $(t\in{0,1,…,k-1})$ 两条直线之间的路径数，还有其他一些细节懒得写. </p>]]></content>
    
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>组合</tag>
      
      <tag>容斥</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

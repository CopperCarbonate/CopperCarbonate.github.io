<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DTOJ 2485 COCI2015 Kamp 题解</title>
    <link href="/2022/10/31/DTOJ-2485-COCI2015-Kamp-%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/10/31/DTOJ-2485-COCI2015-Kamp-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p><a href="http://59.61.75.5:8018/p/P2485">http://59.61.75.5:8018/p/P2485</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>典型的换根 dp 题，一直没去写，今天补完了.</p><p>首先我们考虑如果从 $1$ 号节点开始怎么做</p><p>注意到如果需要回到根节点，答案是好维护的.</p><p>记 $f_u$ 表示从 $u$ 出发，走完所有 $u$ 子树内的点，回到 $u$ 的最小路程.</p><p>那么不需要回到根节点的答案就是 $ans_u&#x3D;f_u-\max{d_u}$ ，$d_u$ 是 $u$ 到 $1$ 的距离</p><p>状态转移也是容易的<br>$$<br>f_u&#x3D;\sum_{f_v&gt;0\or v\in S}(f_v+2w_{u,v})\<br>mx_u&#x3D;\max{mx_v+w_{u,v}}\<br>$$<br>（ $mx_u$ 表示 $\max{d_u}$ , $S$ 表示 $k$ 个特殊点的集合）</p><p>考虑如何换根 dp</p><p>$f_u$ 是好换根的<br>$$<br>f_u’&#x3D;f_u-(f_v+2w_{u,v})\<br>f_v’&#x3D;f_v+(f_u’+2w_{u,v})<br>$$<br>（注意要判子树里有没有点）</p><p>$mx_u$ 比较难换根，需要再维护一个次大值.</p><p>我直接全部存起来了（这做法不太好，容易导致 CSP T1 炸掉）</p><p>维护方法看代码</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fs first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n,k,tg[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> v,w; &#125;;<br>vector&lt;edge&gt; g[N];<br>ll ans[N],f[N]; <br>set&lt;pair&lt;ll,<span class="hljs-type">int</span>&gt; &gt; d[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">mx</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123; <span class="hljs-built_in">assert</span>(d[u].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>); <span class="hljs-keyword">return</span> (*d[u].<span class="hljs-built_in">rbegin</span>()).fs; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> prv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(tg[u]) d[u].<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">0ll</span>,u&#125;);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:g[u])<br>&#123;<br><span class="hljs-keyword">if</span>(e.v==prv) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs1</span>(e.v,u);<br><span class="hljs-keyword">if</span>(f[e.v] <span class="hljs-keyword">or</span> tg[e.v]) f[u]+=f[e.v]+e.w*<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(d[e.v].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>) d[u].<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-built_in">mx</span>(e.v)+e.w,e.v&#125;);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> prv)</span></span><br><span class="hljs-function"></span>&#123;<br>ans[u]=f[u]-<span class="hljs-built_in">mx</span>(u);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:g[u])<br>&#123;<br><span class="hljs-type">int</span> v=e.v;<br><span class="hljs-keyword">if</span>(v==prv) <span class="hljs-keyword">continue</span>;<br>ll fu=f[u]-((f[v] <span class="hljs-keyword">or</span> tg[v])?f[v]+<span class="hljs-number">2</span>*e.w:<span class="hljs-number">0</span>);<br>ll fv=f[v]+((fu <span class="hljs-keyword">or</span> tg[u])?fu+<span class="hljs-number">2</span>*e.w:<span class="hljs-number">0</span>);<br>ll tmpv;<br><span class="hljs-keyword">if</span>(d[u].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) tmpv=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((*d[u].<span class="hljs-built_in">rbegin</span>()).sc==v) tmpv=(d[u].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)?e.w+(*(++d[u].<span class="hljs-built_in">rbegin</span>())).fs:<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> tmpv=<span class="hljs-built_in">mx</span>(u)+e.w;<br>ll tmpu=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(d[v].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>) tmpu=<span class="hljs-built_in">mx</span>(v)+e.w;<br><span class="hljs-keyword">if</span>(tmpv&gt;=<span class="hljs-number">0</span>) d[v].<span class="hljs-built_in">insert</span>(&#123;tmpv,u&#125;); <span class="hljs-keyword">if</span>(tmpu&gt;=<span class="hljs-number">0</span>) d[u].<span class="hljs-built_in">erase</span>(&#123;tmpu,v&#125;);<br><span class="hljs-built_in">swap</span>(f[u],fu),<span class="hljs-built_in">swap</span>(f[v],fv);<br><span class="hljs-built_in">dfs2</span>(e.v,u);<br><span class="hljs-built_in">swap</span>(f[u],fu),<span class="hljs-built_in">swap</span>(f[v],fv);<br><span class="hljs-keyword">if</span>(tmpv&gt;=<span class="hljs-number">0</span>) d[v].<span class="hljs-built_in">erase</span>(&#123;tmpv,u&#125;); <span class="hljs-keyword">if</span>(tmpu&gt;=<span class="hljs-number">0</span>) d[u].<span class="hljs-built_in">insert</span>(&#123;tmpu,v&#125;);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,u,v,w; i&lt;n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w),g[u].<span class="hljs-built_in">push_back</span>(&#123;v,w&#125;),g[v].<span class="hljs-built_in">push_back</span>(&#123;u,w&#125;);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,u; i&lt;=k; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;u),tg[u]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>换根dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DTOJ 3498 无限剑制 题解</title>
    <link href="/2022/10/26/DTOJ-3498-%E6%97%A0%E9%99%90%E5%89%91%E5%88%B6-%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/10/26/DTOJ-3498-%E6%97%A0%E9%99%90%E5%89%91%E5%88%B6-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="DTOJ-3498-无限剑制-题解"><a href="#DTOJ-3498-无限剑制-题解" class="headerlink" title="DTOJ 3498 无限剑制 题解"></a>DTOJ 3498 无限剑制 题解</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>链接：<a href="http://59.61.75.5:8018/p/P3498">http://59.61.75.5:8018/p/P3498</a></p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>​*<strong>I am the bone of my sword.*</strong> </p><p>​*<strong>体は剣で出来ている.*</strong> </p><p>​*<strong>Steel is my body, and fire is my blood.*</strong> </p><p>​*<strong>血潮は鉄で 心は硝子.*</strong> </p><p>​*<strong>I have created over a thousand blades.*</strong> </p><p>​*<strong>几たびの戦场を越えて不败.*</strong> </p><p>​*<strong>Unknown to Death.*</strong> </p><p>​*<strong>ただの一度も败走はなく.*</strong> </p><p>​*<strong>Nor known to Life.*</strong> </p><p>​*<strong>ただの一度も理解されない.*</strong> </p><p>​*<strong>Have withstood pain to create many weapons.*</strong> </p><p>​*<strong>彼の者は常に独り 剣の丘で胜利に酔う.*</strong> </p><p>​*<strong>Yet, those hands will never hold anything.*</strong> </p><p>​*<strong>故に、生涯に意味はなく.*</strong> </p><p>​*<strong>So as I pray, Unlimited Blade Works.*</strong> </p><p>​*<strong>その体は、きっと剣で出来ていた.*</strong> </p><p>​<strong>“无限剑制”</strong> </p><p>​<strong>等级：E~A＋＋</strong> </p><p>​<strong>种类：？？</strong> </p><p>​<strong>Unlimited Blade Works。</strong> </p><p>​<strong>被称为固有结界的特殊魔术。</strong> </p><p>​<strong>在一定时间内，将现实改写为心象世界，至今为止术者见过并能够认知的武器、在这个地方使用过的武器都能瞬间复制、保存。</strong> </p><p>​<strong>但是，复制的武器等级会下降一级。</strong> </p><p>​ </p><p>​Emiya打算增加自己固有结界内的武器数量。他初始有 $ 5 $ 把武器，编号为 $ 1-5 $ ,每把武器有 $ n(n \le 10^5) $ 个属性数值 $ v_i $ 。Emiya接着制作 $ m $ 把新武器，第 $ i $ 次会选择编号为 $ a_i,b_i $ 的武器为模板投影出一把新的武器，新的武器的编号为 $ 5+i $ ，每一个属性的值为两个模板武器对应属性的值的 $ max $ 或 $ min $ 。同时Emiya想知道新的武器的第 $ k_i $ 个属性的数值。但是Emiya还要去做饭，所以需要他的master你来回答这些问题。 </p><h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>​第 $ 1 $ 行两个正整数 $ n,m $ 。 </p><p>​第 $ 2 $ 到 $ 6 $ 行，每行 $ n $ 个正整数，第 $ i $ 个数表示 $ v_i $ 。 </p><p>​第 $ 7 $ 到 $ 6+m $ 行，每行 $ 4 $ 个数 $ p_i,a_i,b_i,k_i $ ，其中模板武器为 $ a_i,b_i $ ， $ p_i&#x3D;0 $ 为 $ min $ ， $ p_i&#x3D;1 $ 为 $ max $ ，查询第 $ k_i $ 个属性的数值。 </p><h3 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h3><p>​ $ m $ 行，每行 $ 1 $ 个整数，表示第 $ k_i $ 个属性的数值 </p><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">6 3<br>1 5 9 3 8 6 <br>4 1 1 4 9 3 <br>8 7 7 8 10 8 <br>9 8 6 9 3 4 <br>5 3 4 1 1 2 <br>0 2 5 6<br>0 4 3 6<br>1 7 4 1<br></code></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br>4<br>9<br></code></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>​保证对于每一个属性，初始 $ 5 $ 把武器该属性的数值不同。 </p><p>​ $ 10 % $ ： $ n \le 10^3,m \le 10^3 $ 。 </p><p>​另外 $ 20 % $ ： $ m \le 5 \times 10^3 $  </p><p>​另外 $ 20 % $ ： $ a_i \le 5,b_i $ 随机生成 </p><p>​另外 $ 20 % $ ：所有 $ v_i $ 值域在 $ [1,5] $  </p><p>​ $ 100 % $ ： $ k_i \le n \le 10^5,m \le 10^5,a_i,b_i \le 4+i,v_i \le 10^9 $ </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>想了好久，其实很水tt</p><p>想写题解主要是因为这题题面是 Fate 很有意思</p><p>我们注意到 “所有 $ v_i $ 值域在 $ [1,5] $” 这个部分分，这种情况下，初始的不同情况数只有 $5!&#x3D;120$ 种，可以直接暴力做</p><p>没有这个限制直接离散化就好了.</p><p>所以最终做法就是：对每一位分别考虑，发现离散化后只有 $5!&#x3D;120$ 种不同情况，然后对 $120$ 种情况都暴力进行 <strong>Unlimited Blade Works</strong> ，然后回答询问，时间复杂度 $\Theta(5!\cdot m)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> fc[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">24</span>,<span class="hljs-number">120</span>,<span class="hljs-number">720</span>&#125;;<br><span class="hljs-type">int</span> n,m,v[N][<span class="hljs-number">6</span>],w[N][<span class="hljs-number">6</span>],p[<span class="hljs-number">125</span>][<span class="hljs-number">6</span>],r[<span class="hljs-number">125</span>][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">perm_to_id</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">5</span>; j++) <span class="hljs-keyword">if</span>(w[k][j]&lt;w[k][i]) cnt++;<br>ans+=cnt*fc[<span class="hljs-number">5</span>-i];<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) p[<span class="hljs-number">1</span>][i]=i;<br><span class="hljs-type">int</span> c=<span class="hljs-number">1</span>; <span class="hljs-keyword">do</span> &#123; c++; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) p[c][i]=p[c<span class="hljs-number">-1</span>][i]; &#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(p[c]+<span class="hljs-number">1</span>,p[c]+<span class="hljs-number">6</span>)); c--;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=c; j++) r[j][i]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">5</span>; j++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;v[i][j]);<br><span class="hljs-type">int</span> d[<span class="hljs-number">6</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">5</span>; j++) d[j]=j;<br><span class="hljs-built_in">sort</span>(d+<span class="hljs-number">1</span>,d+<span class="hljs-number">6</span>,[&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y)&#123; <span class="hljs-keyword">return</span> v[i][x]&lt;v[i][y] <span class="hljs-built_in">or</span> (v[i][x]==v[i][y] <span class="hljs-keyword">and</span> x&lt;y); &#125;);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">5</span>; j++) w[i][d[j]]=j;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">6</span>; j&lt;=m+<span class="hljs-number">5</span>; j++)<br>&#123;<br><span class="hljs-type">int</span> op,a,b,k; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;op,&amp;a,&amp;b,&amp;k);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=c; i++)<br><span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>) r[i][j]=(p[i][r[i][a]]&lt;p[i][r[i][b]])?r[i][b]:r[i][a];<br><span class="hljs-keyword">else</span> r[i][j]=(p[i][r[i][a]]&gt;p[i][r[i][b]])?r[i][b]:r[i][a];<br><span class="hljs-type">int</span> pn=<span class="hljs-built_in">perm_to_id</span>(k)+<span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,v[k][r[pn][j]]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这边用了 Cantor 展开求排列的顺序，也可以用哈希写.</p>]]></content>
    
    
    
    <tags>
      
      <tag>思维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DTOJ 6316 沙丘 题解</title>
    <link href="/2022/10/24/DTOJ-6316-%E6%B2%99%E4%B8%98-%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/10/24/DTOJ-6316-%E6%B2%99%E4%B8%98-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="DTOJ-6316-沙丘-题解"><a href="#DTOJ-6316-沙丘-题解" class="headerlink" title="DTOJ 6316 沙丘 题解"></a>DTOJ 6316 沙丘 题解</h1><h4 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h4><p><a href="http://59.61.75.5:8018/p/P6316">http://59.61.75.5:8018/p/P6316</a></p><p>在满天的星光下，灰大狼一人孤独地堆起了小沙丘。有 $n$ 堆沙丘，每堆沙丘有相对高度 $h_i$，每次灰大狼可以选择一段连续的沙丘并将它们高度增加或减少 $a$ 或 $b$，其中 $a,b$ 给定，灰大狼想知道最少要几次才能把所有沙丘的相对高度都变成 $0$。如果无解请输出 <code>-1</code>。</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>首先看到是 “一段连续的沙丘”，果断考虑差分. </p><p>差分完增加或减小 $a$ 或 $b$ 可以被转化成两个位置上分别  $+a, -a$  或 $+b, -b$  </p><p>最后每个位置上一定是 $xa+yb$ 的形式，记差分数组为 ${d_i}$，则 $xa+yb&#x3D;d_i$ </p><p>显然是可以 exgcd 求出一组特解 $x_0,y_0$</p><p>于是通解可以表示成 $\begin{cases}x&#x3D;x_0+\frac{b}{\gcd(a,b)}\cdot k\ y&#x3D;y_0-\frac{a}{\gcd(a,b)}\cdot k\end{cases}$</p><p>最后答案即 $\frac{1}{2}\sum(|x|+|y|)$</p><p>测试的时候我直接调整每个 $x,y$ 使 $|x|+|y|$ 最小. </p><p>$|x|+|y|&#x3D;|x_0+\frac{b}{\gcd(a,b)}\cdot k|+ |y_0-\frac{a}{\gcd(a,b)}\cdot k|$</p><p>根据高一数学，这一定是三个一次函数组成的分段函数.</p><p>于是最小值一定只有四种情况， $x$ 最小正值，$x$ 最大负值， $y$ 最小正值，$y$ 最大负值.</p><p>但是我们发现这么做有个问题，就是差分数组要满足  $\sum x &#x3D; 0$ 且 $\sum y &#x3D; 0$</p><blockquote><p>上次数竞比赛也是没注意到限制条件少了50分ww</p></blockquote><p>考虑继续调整，注意到 $\sum x &#x3D;0 \Rightarrow \sum y &#x3D;0$ 所以只需要调整  $\sum x &#x3D; 0$ </p><p>不妨设 $\sum x &gt; 0$ 我们对于一个位置 $i$，若 $\sum x$ 变化 $1$， 则 $|x|+|y|$ 变化 $|x-\frac{b}{gcd(a,b)}|-|x|$</p><p>把所有的变化存进堆里，从小到大取出来. </p><p>嗯这就做完了 $(\and \omega\and)$</p><p>代码好难写（码力不够</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x,f=<span class="hljs-number">0</span>; <span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch=<span class="hljs-built_in">getchar</span>())) <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(x=(ch^<span class="hljs-number">48</span>); <span class="hljs-built_in">isdigit</span>(ch=<span class="hljs-built_in">getchar</span>()); x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>));<br><span class="hljs-keyword">return</span> f?-x:x;<br>&#125;<br><span class="hljs-type">int</span> n,a,b,c[N],x[N],y[N];<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; Q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(!b) &#123; x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<br><span class="hljs-type">int</span> d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x); y-=(a/b)*x;<br><span class="hljs-keyword">return</span> d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>n=<span class="hljs-built_in">rd</span>(),a=<span class="hljs-built_in">rd</span>(),b=<span class="hljs-built_in">rd</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) c[i]=<span class="hljs-built_in">rd</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=++n; i; --i) c[i]=c[i]-c[i<span class="hljs-number">-1</span>];<br><span class="hljs-type">int</span> tx,ty,d=<span class="hljs-built_in">exgcd</span>(a,b,tx,ty); a/=d,b/=d;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(c[i]%d) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br><span class="hljs-type">int</span> X=((ll)tx*c[i]/d%b+b)%b,Y=(c[i]/d-(ll)a*X)/b;<br>x[i]=X,y[i]=Y;<br>X-=b,Y+=a;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(X)+<span class="hljs-built_in">abs</span>(Y)&lt;<span class="hljs-built_in">abs</span>(x[i])+<span class="hljs-built_in">abs</span>(y[i])) x[i]=X,y[i]=Y;<br>Y=((ll)ty*c[i]/d%a+a)%a,X=(c[i]/d-(ll)b*Y)/a;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(X)+<span class="hljs-built_in">abs</span>(Y)&lt;<span class="hljs-built_in">abs</span>(x[i])+<span class="hljs-built_in">abs</span>(y[i])) x[i]=X,y[i]=Y;<br>Y-=a,X+=b;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(X)+<span class="hljs-built_in">abs</span>(Y)&lt;<span class="hljs-built_in">abs</span>(x[i])+<span class="hljs-built_in">abs</span>(y[i])) x[i]=X,y[i]=Y;<br>&#125;<br>ll s=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) s+=x[i];<br>s/=b;<br><span class="hljs-keyword">if</span>(s&lt;<span class="hljs-number">0</span>) s=-s,<span class="hljs-built_in">swap</span>(a,b),<span class="hljs-built_in">swap</span>(x,y);<br><span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;p)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(x[p]-b)+<span class="hljs-built_in">abs</span>(y[p]+a)-<span class="hljs-built_in">abs</span>(x[p])-<span class="hljs-built_in">abs</span>(y[p]); &#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(-<span class="hljs-built_in">f</span>(i),i));<br><span class="hljs-keyword">while</span>(s--)<br>&#123;<br><span class="hljs-type">int</span> p=Q.<span class="hljs-built_in">top</span>().second; Q.<span class="hljs-built_in">pop</span>();<br>x[p]-=b,y[p]+=a;<br>Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(-<span class="hljs-built_in">f</span>(p),p));<br>&#125;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) ans+=<span class="hljs-built_in">abs</span>(x[i])+<span class="hljs-built_in">abs</span>(y[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans/<span class="hljs-number">2</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>差分</tag>
      
      <tag>exgcd</tag>
      
      <tag>贪心</tag>
      
      <tag>反悔贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DTOJ 5932 Counting 题解</title>
    <link href="/2022/10/22/DTOJ-5932-Counting-%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/10/22/DTOJ-5932-Counting-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="DTOJ-5932-Counting-题解"><a href="#DTOJ-5932-Counting-题解" class="headerlink" title="DTOJ 5932 Counting 题解"></a>DTOJ 5932 Counting 题解</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://59.61.75.5:8018/p/P5932">http://59.61.75.5:8018/p/P5932</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>认识到了生成函数很好用，于是摆了一篇题解</p><h3 id="10分"><a href="#10分" class="headerlink" title="10分"></a>10分</h3><p>直接dp，$f_{i,j}$ 表示走了 $i$ 步之后，当前位置在  $j$ 的方案数</p><p>然后就有状态转移方程 $f_{i,j}&#x3D;f_{i-1,j-1}+f_{i-1,j}+f_{i-1,j+1}$</p><p>时间复杂度 $\Theta(nm)$</p><h3 id="40-50分"><a href="#40-50分" class="headerlink" title="40~50分"></a>40~50分</h3><p>相信大家都会矩阵快速幂<br>$$<br>\begin {bmatrix}<br>1 &amp; 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0\<br>1 &amp; 1 &amp; 1 &amp; 0 &amp; \cdots &amp; 0\<br>0 &amp; 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 0\<br>0 &amp; 0 &amp; 1 &amp; 1 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1<br>\end {bmatrix}<br>\begin {bmatrix}<br>f_{i-1,0} \<br>f_{i-1,1} \<br>f_{i-1,2} \<br>f_{i-1,3} \<br>\vdots  \<br>f_{i-1,n-1} \<br>\end {bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>f_{i,0} \<br>f_{i,1} \<br>f_{i,2} \<br>f_{i,3} \<br>\vdots  \<br>f_{i,n-1} \<br>\end{bmatrix}<br>$$</p><h3 id="80-90分"><a href="#80-90分" class="headerlink" title="80~90分"></a>80~90分</h3><p>相信大家都学过 Catalan 数</p><p>我们先枚举走的 $n $ 步中，有 $k$ 次是移动，$n-k$ 次是原地不动，有 $\binom{n}{k}$ 种方法</p><p>把向左移动记为 $(1,1)$，向右移动记为 $(1,-1)$，则可以表示成下图这样</p><p><img src="/%22/img/post_img/DTOJ_5932_pic1.png%22"></p><p>这边比 Catalan 数那个图多了一条线，于是我们考虑容斥，可以得到：</p><p>方案数 $&#x3D;$ 总路径数 </p><p>$-$ 越过 $y&#x3D;m$ 的路径数 $-$ 越过 $y&#x3D;0$ 的路径数 </p><p>$+$ 先越过 $y&#x3D;0$ 再越过 $y&#x3D;m$ 的路径数 $+$ 先越过 $y&#x3D;m$ 再越过$y&#x3D;0$ 的路径数 </p><p>$-$ 越过 $3$ 次的路径数 </p><p>$+$ … </p><p>所以可以把终点 $(k,0)$ 关于 $y&#x3D;0$ 和 $y&#x3D;m$ 交替对称，加上或者减去到每个点的路径数</p><p> $(k,0) \rightarrow (k,-2) \rightarrow (k,2m+4) \rightarrow (k,-2m-6) \rightarrow\dots$</p><p> $(k,0) \rightarrow (k,2m+2) \rightarrow (k,-2m-4) \rightarrow (k,4m+6) \rightarrow\dots$</p><p>于是可以写出组合式子<br>$$<br>ans&#x3D;\sum_{k&#x3D;0}^n\binom{n}{k}\left(\left(\binom{k}{k&#x2F;2}-\binom{k}{k&#x2F;2-1}+\binom{k}{k&#x2F;2+m+2}-\dots\right)+\left(\binom{k}{k&#x2F;2}-\binom{k}{k&#x2F;2-1}+\binom{k}{k&#x2F;2+m+2}-\dots\right)\right)<br>$$<br>因为最多可以越过$\frac{n}{m}$ 条线，所以时间复杂度是 $\Theta(\frac{n^2}{m})$</p><h3 id="100分"><a href="#100分" class="headerlink" title="100分"></a>100分</h3><p>可以发现dp式子可以写成卷积，于是考虑把式子改写成生成函数</p><p>$F_i(x)&#x3D;\left(\frac{1}{x}+1+x\right)F_{i-1}(x)$</p><p>则$F_n(x)&#x3D;\left(\frac{1}{x}+1+x\right)^n$</p><p>答案即为 $[x^0]F_n(x)&#x3D;[x^0]\left(\frac{1}{x}+1+x\right)^n&#x3D;[x^n]\left(1+x+x^2\right)^n$</p><p>记 $G&#x3D;1+x+x^2$  $H&#x3D;G^n$ </p><p>使用奇妙的小技巧（求导）：$H’&#x3D;nG^{n-1}G’$</p><p>同乘G得 $H’G&#x3D;nHG’$ </p><p>我们得到了一个好式子，就可以 $\Theta(n)$ 推出答案了</p><p>把 $H$ 和 $H’$ 写成展开形式： $H(x)&#x3D;\sum{h_ix^i}$   </p><p>$H’(x)&#x3D;\sum{ih_ix^i}&#x3D;\sum{(i+1)h_{i+1}x^i}$</p><p>又因为 $H’(x)(1+x+x^2)&#x3D;nH(x)(1+2x)$</p><p>求 $[x^k]$ 一项得 $<a href="(k+1)h_%7Bk+1%7D+kh_k+(k-1)h_%7Bk-1%7D">x^k</a>&#x3D;[x^k]n(h_k+2h_{k-1})$</p><p>整理得 $(k+1)h_{k+1}&#x3D;(n-k)h_k+(2n-k+1)h_{k-1}$</p><p>因为 $H&#x3D;(1+x+x^2)^n$ 所以 $h_0&#x3D;0, h_1&#x3D;n$ 就可以递推求得 $h_i$ 了呢（记得线性求逆元）</p><p>$h_i&#x3D;<a href="1+x+x%5E2">x^i</a>^n&#x3D;<a href="%5Cfrac%7B1%7D%7Bx%7D+1+x">x^{i-n}</a>^n$</p><p> 所以 $h_i$ 表示的就是 $n$ 步走到 $i-n$ 的方案数</p><p>浅浅地容斥一下就可以得到答案</p><p>时间复杂度是 $\Theta(n)$ 的</p><p>发现很好实现 我直呼好题</p>]]></content>
    
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>组合</tag>
      
      <tag>生成函数</tag>
      
      <tag>求导</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DTOJ 5769 下棋 题解</title>
    <link href="/2022/10/22/DTOJ-5769-%E4%B8%8B%E6%A3%8B-%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/10/22/DTOJ-5769-%E4%B8%8B%E6%A3%8B-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="DTOJ-5769-下棋-题解"><a href="#DTOJ-5769-下棋-题解" class="headerlink" title="DTOJ 5769 下棋 题解"></a>DTOJ 5769 下棋 题解</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://59.61.75.5:8018/p/P5769">http://59.61.75.5:8018/p/P5769</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先比较容易想到 $dp$ , 因为任意一段绝对值不超过 $k$ ，所以白棋个数减黑棋个数要在 $[-k,k]$ 区间里，我们于是考虑把状态设为白棋减黑棋个数的最大值和最小值. </p><p>具体来说 $f_{i,j,a,b}$ 表示用了 $i$ 个白，$j$ 个黑， 白减黑最大值和最小值分别为 $a,b$ .</p><p>转移较显然，时间复杂度 $O(n^2k^2)$</p><p>因为 $|i-j|\in[-k,k]$ 所以可以优化到 $O(nk^3)$ ，$f_{i,j,a,b}$ 的 $j$ 表示原来的 $i-j$</p><p>继续优化，考虑将白棋看做向上一步，黑棋看做向右一步，问题即可转化为求到 $(n,m)$ 的方案数，其中路径上点 $\max{x-y}-\min{x-y}\leq k$， 即路径在 $x-y&#x3D;k-t$ 和  $x-y&#x3D;-t$  $(t\in{0,1,…,k})$ 两条直线之间. 显然类似卡塔兰数的方格路径计数，因为两条线，需要容斥，时间复杂度 $O(nk)$. </p><p>由于 $\max{x-y}-\min{x-y} &lt; k$ 的答案会被算多次，需要减去路径在 $x-y&#x3D;(k-1)-t$ 和  $x-y&#x3D;-t$  $(t\in{0,1,…,k-1})$ 两条直线之间的路径数，还有其他一些细节懒得写. </p>]]></content>
    
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>组合</tag>
      
      <tag>容斥</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
